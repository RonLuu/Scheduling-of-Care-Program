<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Care Program – Access & Auth</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        font-family: system-ui, sans-serif;
        margin: 0;
        background: #f7f7fb;
      }
      header {
        background: #1f2937;
        color: #fff;
        padding: 12px 16px;
        display: flex;
        justify-content: space-between;
      }
      main {
        max-width: 900px;
        margin: 24px auto;
        padding: 0 16px;
      }
      .card {
        background: #fff;
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 16px;
      }
      input,
      select,
      button {
        padding: 10px;
        border-radius: 8px;
        border: 1px solid #d1d5db;
        width: 100%;
        margin: 6px 0 12px;
      }
      button {
        background: #2c3f70;
        color: white;
        cursor: pointer;
      }
      button.secondary {
        background: #fff;
        color: #2c3f70;
        border: 1px solid #d1d5db;
      }
      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }
      .badge {
        padding: 2px 8px;
        border-radius: 999px;
        background: #eef2ff;
        color: #3730a3;
        font-size: 12px;
      }
      nav a {
        color: #d1d5db;
        margin-left: 12px;
        text-decoration: none;
      }
      nav a.active {
        color: #fff;
        text-decoration: underline;
      }
      code {
        background: #f3f4f6;
        padding: 2px 6px;
        border-radius: 6px;
      }
    </style>
  </head>
  <body>
    <header>
      <div>
        <strong>Care Program</strong>
        <span style="opacity: 0.7">· Care Item & Care Task</span>
      </div>
      <nav>
        <a href="#" id="nav-login">Login</a>
        <a href="#" id="nav-register">Register</a>
        <a href="#" id="nav-dashboard">Dashboard</a>
      </nav>
    </header>
    <main><div id="root"></div></main>

    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

    <script type="text/babel" data-presets="react">
      const API = "/api";

      function useAuth() {
        const [me, setMe] = React.useState(null);
        React.useEffect(() => {
          const jwt = localStorage.getItem("jwt");
          if (!jwt) return;
          fetch(API + "/auth/me", {
            headers: { Authorization: "Bearer " + jwt },
          })
            .then((r) => r.json())
            .then((d) => setMe(d.user))
            .catch(() => setMe(null));
        }, []);

        // listen for jwt changes (e.g., other tabs) and refresh
        React.useEffect(() => {
          function onStorage(e) {
            if (e.key === "jwt") {
              const jwt = e.newValue;
              if (!jwt) {
                setMe(null);
                return;
              }
              fetch("/api/auth/me", {
                headers: { Authorization: "Bearer " + jwt },
              })
                .then((r) => r.json())
                .then((d) => setMe(d.user))
                .catch(() => setMe(null));
            }
          }
          window.addEventListener("storage", onStorage);
          return () => window.removeEventListener("storage", onStorage);
        }, []);
        return [me, setMe];
      }

      function Login({ onAuthed }) {
        const [email, setEmail] = React.useState("");
        const [password, setPassword] = React.useState("");
        const [err, setErr] = React.useState("");

        async function submit(e) {
          e.preventDefault();
          setErr("");
          const r = await fetch(API + "/auth/login", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ email, password }),
          });
          const d = await r.json();
          if (!r.ok) return setErr(d.error || "Login failed");
          localStorage.setItem("jwt", d.session.jwt);
          onAuthed(d.user);
        }

        return (
          <div className="card">
            <h2>Login</h2>
            <form onSubmit={submit}>
              <input
                placeholder="Email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
              />
              <input
                type="password"
                placeholder="Password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
              />
              <button>Sign in</button>
            </form>
            {err && <p style={{ color: "#b91c1c" }}>{err}</p>}
          </div>
        );
      }

      function Register({ onAuthed }) {
        return (
          <div>
            <RegisterBasic onAuthed={onAuthed} />
            <RegisterOrganization />
          </div>
        );
      }

      function RegisterFamily({ onAuthed, defaultOrganizationId = "" }) {
        const [name, setName] = React.useState("");
        const [email, setEmail] = React.useState("");
        const [password, setPassword] = React.useState("");
        const [organizationId, setOrganizationId] = React.useState(
          defaultOrganizationId
        );
        const [err, setErr] = React.useState("");

        React.useEffect(() => {
          if (defaultOrganizationId) setOrganizationId(defaultOrganizationId);
        }, [defaultOrganizationId]);

        async function submit(e) {
          e.preventDefault();
          setErr("");
          const r = await fetch("/api/auth/register-family", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name, email, password, organizationId }),
          });
          const d = await r.json();
          if (!r.ok) return setErr(d.error || "Registration failed");
          localStorage.setItem("jwt", d.session.jwt);
          onAuthed(d.user);
        }

        return (
          <div className="card">
            <h2>Register as a new family member</h2>
            <form onSubmit={submit}>
              <input
                placeholder="Full name"
                value={name}
                onChange={(e) => setName(e.target.value)}
              />
              <input
                placeholder="Email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
              />
              <input
                type="password"
                placeholder="Password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
              />
              <input
                placeholder="Organization ID"
                value={organizationId}
                onChange={(e) => setOrganizationId(e.target.value)}
              />
              <button>Create family account</button>
            </form>
            {err && <p style={{ color: "#b91c1c" }}>{err}</p>}
          </div>
        );
      }

      function RegisterOrganization() {
        const [name, setName] = React.useState("");
        const [address, setAddress] = React.useState("");
        const [org, setOrg] = React.useState(null);
        const [err, setErr] = React.useState("");
        const [busy, setBusy] = React.useState(false);

        async function submit(e) {
          e.preventDefault();
          setErr("");
          setBusy(true);
          setOrg(null);
          try {
            const r = await fetch("/api/organizations", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ name, address }),
            });
            const d = await r.json();
            if (!r.ok)
              throw new Error(d.error || "Failed to create organisation");
            setOrg(d); // d should contain _id, name, address
          } catch (e2) {
            setErr(e2.message || String(e2));
          } finally {
            setBusy(false);
          }
        }

        return (
          <div className="card">
            <h2>Register Organization</h2>
            <form onSubmit={submit}>
              <input
                placeholder="Organisation name"
                value={name}
                onChange={(e) => setName(e.target.value)}
              />
              <input
                placeholder="Address"
                value={address}
                onChange={(e) => setAddress(e.target.value)}
              />
              <button disabled={busy}>
                {busy ? "Creating..." : "Create organisation"}
              </button>
            </form>
            {err && <p style={{ color: "#b91c1c" }}>Error: {err}</p>}
            {org && (
              <p>
                Created: <strong>{org.name}</strong>
                <br />
                Organisation ID: <code>{org._id}</code>
              </p>
            )}
          </div>
        );
      }

      function RegisterBasic({ onAuthed }) {
        const [name, setName] = React.useState("");
        const [email, setEmail] = React.useState("");
        const [password, setPassword] = React.useState("");
        const [role, setRole] = React.useState("Family"); // default
        const [err, setErr] = React.useState("");

        async function submit(e) {
          e.preventDefault();
          setErr("");
          const r = await fetch("/api/auth/register-basic", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name, email, password, role }),
          });

          const d = await r.json();
          if (!r.ok) return setErr(d.error || "Registration failed");
          localStorage.setItem("jwt", d.session.jwt);
          onAuthed(d.user);
        }

        return (
          <div className="card">
            <h2>Register User</h2>
            <form onSubmit={submit}>
              <div className="row">
                <div>
                  <input
                    placeholder="Full name"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                  />
                  <input
                    placeholder="Email"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                  />
                  <input
                    type="password"
                    placeholder="Password"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                  />
                </div>
                <div>
                  <label>Role</label>
                  <select
                    value={role}
                    onChange={(e) => setRole(e.target.value)}
                  >
                    <option value="Family">Family</option>
                    <option value="PoA">PoA</option>
                    <option value="Admin">Admin</option>
                    <option value="GeneralCareStaff">GeneralCareStaff</option>
                  </select>
                </div>
              </div>
              <button>Create account</button>
            </form>
            {err && <p style={{ color: "#b91c1c" }}>{err}</p>}
          </div>
        );
      }

      function Dashboard({ me, onLogout }) {
        const jwt = localStorage.getItem("jwt");
        const initialType =
          me && me.role === "Admin" ? "STAFF_INVITE" : "MANAGER_TOKEN";
        const [type, setType] = React.useState(initialType);
        const [organizationId, setOrganizationId] = React.useState(
          (me && me.organizationId) || ""
        );
        const [expiresInDays, setExpiresInDays] = React.useState(7);
        const [maxUses, setMaxUses] = React.useState(1);
        const [tokenResult, setTokenResult] = React.useState(null);
        const [list, setList] = React.useState([]);

        const [clients, setClients] = React.useState([]);

        const [newPName, setNewPName] = React.useState("");
        const [newPDob, setNewPDob] = React.useState(""); // yyyy-mm-dd
        const [newPMed, setNewPMed] = React.useState("");

        const [newPBudgetType, setNewPBudgetType] = React.useState("Year"); // Year | Month | Week
        const [newPBudgetAmt, setNewPBudgetAmt] = React.useState("");

        const [adding, setAdding] = React.useState(false);
        const [addErr, setAddErr] = React.useState("");

        const [selectedPersonId, setSelectedPersonId] = React.useState("");

        // --- Create Care Need Item form state ---
        const [ciPersonId, setCiPersonId] = React.useState("");
        const [ciName, setCiName] = React.useState("");
        const [ciDesc, setCiDesc] = React.useState("");
        const [ciCategory, setCiCategory] = React.useState("HygieneProducts");
        const [ciCategories, setCiCategories] = React.useState([
          "HygieneProducts",
          "Clothing",
          "Health",
          "Entertainment",
          "Other",
        ]);
        const [ciUseCustomCat, setCiUseCustomCat] = React.useState(false);
        const [ciCustomCat, setCiCustomCat] = React.useState("");

        const [ciIntervalType, setCiIntervalType] = React.useState("Daily");
        const [ciIntervalValue, setCiIntervalValue] = React.useState(1);
        const [ciStartDate, setCiStartDate] = React.useState(); // yyyy-mm-dd
        const [ciEndMode, setCiEndMode] = React.useState("none"); // "none" | "endDate" | "count"
        const [ciEndDate, setCiEndDate] = React.useState("");

        const [ciBudgetCost, setCiBudgetCost] = React.useState(0);
        const [ciPurchaseCost, setCiPurchaseCost] = React.useState(0);
        const [ciOccurrenceCount, setCiOccurrenceCount] = React.useState("");

        const [ciOccurrenceCost, setCiOccurrenceCost] = React.useState(0);

        const [ciScheduleType, setCiScheduleType] = React.useState("AllDay"); // "AllDay" | "Timed"
        const [ciStartTime, setCiStartTime] = React.useState("09:00"); // HH:mm
        const [ciEndTime, setCiEndTime] = React.useState("10:00"); // HH:mm

        const [ciBusy, setCiBusy] = React.useState(false);
        const [ciErr, setCiErr] = React.useState("");
        const [ciSuccess, setCiSuccess] = React.useState("");

        // --- Care Need Items listing state ---
        const [cniClientId, setCniClientId] = React.useState(""); // selected client for item list
        const [cniItems, setCniItems] = React.useState([]);
        const [cniLoading, setCniLoading] = React.useState(false);
        const [cniErr, setCniErr] = React.useState("");

        const [tasksClientId, setTasksClientId] = React.useState("");
        const [tasks, setTasks] = React.useState([]);
        const [tasksLoading, setTasksLoading] = React.useState(false);
        const [tasksErr, setTasksErr] = React.useState("");

        // --- Comments / Files state ---
        const [openCommentsFor, setOpenCommentsFor] = React.useState(null); // taskId or null
        const [openFilesFor, setOpenFilesFor] = React.useState(null); // taskId or null

        const [commentsByTask, setCommentsByTask] = React.useState({}); // { [taskId]: [...] }
        const [filesByTask, setFilesByTask] = React.useState({}); // { [taskId]: [...] }

        const [newCommentText, setNewCommentText] = React.useState(""); // input for current openCommentsFor

        // simple link uploads (url/path)
        const [newFile, setNewFile] = React.useState({
          filename: "",
          urlOrPath: "",
          fileType: "",
          size: "",
          description: "",
        });

        // draft cost per task id (string values so inputs are controlled)
        const [costDraftByTask, setCostDraftByTask] = React.useState({});

        // cost editor visibility per task
        const [costEditorHiddenByTask, setCostEditorHiddenByTask] =
          React.useState({});

        const [reportClientId, setReportClientId] = React.useState("");
        const [reportYear, setReportYear] = React.useState(
          new Date().getFullYear()
        );
        const [report, setReport] = React.useState(null);
        const [reportErr, setReportErr] = React.useState("");
        const aud = new Intl.NumberFormat("en-AU", {
          style: "currency",
          currency: "AUD",
        });

        const [pendingOrgId, setPendingOrgId] = React.useState(
          me.organizationId || ""
        );
        const [orgSaveMsg, setOrgSaveMsg] = React.useState("");

        const [token, setToken] = React.useState("");
        const [reqMsg, setReqMsg] = React.useState("");
        const [reqFeedback, setReqFeedback] = React.useState("");

        const [accessClientId, setAccessClientId] = React.useState("");
        const [accessLinks, setAccessLinks] = React.useState([]);
        const [accessErr, setAccessErr] = React.useState("");

        // Fetch links + persons when dashboard loads
        React.useEffect(() => {
          if (!jwt || !me) return;
          // get links for this user
          fetch(`/api/person-user-links?userId=${me.id}`, {
            headers: { Authorization: "Bearer " + jwt },
          })
            .then((r) => r.json())
            .then(async (links) => {
              //  fetch each person
              const persons = await Promise.all(
                links.map((l) =>
                  fetch(`/api/person-with-needs/${l.personId}`, {
                    headers: { Authorization: "Bearer " + jwt },
                  })
                    .then((r) => r.json())
                    .then((p) => ({
                      ...p,
                      relationshipType: l.relationshipType,
                    }))
                )
              );
              setClients(persons);
            })
            .catch((err) => console.error("Failed to load clients", err));
        }, [jwt, me]);

        React.useEffect(() => {
          if (!jwt) return;
          fetch(API + "/tokens", {
            headers: { Authorization: "Bearer " + jwt },
          })
            .then((r) => r.json())
            .then(setList)
            .catch(() => {});
        }, []);

        function allowedTypesFor(role) {
          if (role === "Admin") return [["STAFF_INVITE", "Staff invite"]];
          if (role === "Family" || role === "PoA")
            return [
              ["FAMILY_TOKEN", "Family invite"],
              ["MANAGER_TOKEN", "Manager invite"],
            ];
          return [];
        }

        async function createToken(e) {
          e.preventDefault();
          if (!selectedPersonId) {
            setTokenResult({ error: "Please select a client." });
            return;
          }

          const r = await fetch(API + "/tokens", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: "Bearer " + jwt,
            },
            body: JSON.stringify({
              type,
              organizationId,
              personIds: [selectedPersonId],
              expiresInDays: Number(expiresInDays),
              maxUses: Number(maxUses),
            }),
          });
          const d = await r.json();
          setTokenResult(r.ok ? d : { error: d.error || "Failed" });
          if (r.ok) {
            const refreshed = await fetch(API + "/tokens", {
              headers: { Authorization: "Bearer " + jwt },
            });
            setList(await refreshed.json());
          }
        }

        function OrgBadge({ me }) {
          return (
            <p>
              Org:{" "}
              {me.organizationId ? (
                <code>{me.organizationId}</code>
              ) : (
                <em>none set</em>
              )}
            </p>
          );
        }

        function IncomingAccessRequests({ jwt }) {
          const [items, setItems] = React.useState([]);
          const [err, setErr] = React.useState("");

          async function load() {
            try {
              setErr("");
              const r = await fetch("/api/access-requests/incoming", {
                headers: { Authorization: "Bearer " + jwt },
              });
              const d = await r.json();
              if (!r.ok) throw new Error(d.error || "Failed to load requests");
              setItems(d);
            } catch (e) {
              setErr(e.message || String(e));
            }
          }
          React.useEffect(() => {
            load();
          }, []);

          async function decide(id, approve) {
            const r = await fetch(`/api/access-requests/${id}/decision`, {
              method: "PATCH",
              headers: {
                "Content-Type": "application/json",
                Authorization: "Bearer " + jwt,
              },
              body: JSON.stringify({ approve }),
            });
            const d = await r.json();
            if (!r.ok) {
              alert(d.error || "Failed");
              return;
            }
            load();
          }

          return (
            <div className="card">
              <h3>Incoming access requests</h3>
              {err && <p style={{ color: "#b91c1c" }}>Error: {err}</p>}
              {items.length === 0 ? (
                <p>No pending requests.</p>
              ) : (
                <ul>
                  {items.map((ar) => (
                    <li key={ar._id} style={{ marginBottom: 8 }}>
                      <span className="badge">{ar.tokenType}</span>{" "}
                      {ar.requesterEmail} ({ar.requesterRole}) · org{" "}
                      <code>{ar.organizationId}</code>
                      {ar.message && (
                        <React.Fragment> · “{ar.message}”</React.Fragment>
                      )}
                      <div style={{ marginTop: 6 }}>
                        <button onClick={() => decide(ar._id, true)}>
                          Approve
                        </button>{" "}
                        <button
                          className="secondary"
                          onClick={() => decide(ar._id, false)}
                        >
                          Reject
                        </button>
                      </div>
                    </li>
                  ))}
                </ul>
              )}
            </div>
          );
        }

        async function addClient(e) {
          e.preventDefault();
          if (!me.organizationId) {
            setAddErr("Please set your organisation first.");
            return;
          }
          if (!me || (me.role !== "Family" && me.role !== "PoA")) return;
          setAdding(true);
          setAddErr("");

          try {
            const annual = toAnnualBudget(newPBudgetType, newPBudgetAmt);

            // 1) Create PersonWithNeeds (org derived from current user on server OR we pass nothing and server derives)
            const r1 = await fetch("/api/person-with-needs", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: "Bearer " + jwt,
              },
              body: JSON.stringify({
                name: newPName,
                dateOfBirth: newPDob
                  ? new Date(newPDob).toISOString()
                  : undefined,
                medicalInfo: newPMed,
                organizationId: me.organizationId,
                // (DO NOT send organizationId; backend should derive from user OR set from your server rules)
                currentAnnualBudget: annual,
              }),
            });
            const p = await r1.json();
            if (!r1.ok) throw new Error(p.error || "Failed to create person");

            // 2) Create PersonUserLink
            const r2 = await fetch("/api/person-user-links", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: "Bearer " + jwt,
              },
              body: JSON.stringify({
                personId: p._id,
                userId: me.id,
                relationshipType: "Family",
                active: true,
                startAt: new Date(),
              }),
            });
            const l = await r2.json();
            if (!r2.ok) throw new Error(l.error || "Failed to link person");

            // 3) Refresh My Clients list
            const linksRes = await fetch(
              `/api/person-user-links?userId=${me.id}`,
              {
                headers: { Authorization: "Bearer " + jwt },
              }
            );
            const links = await linksRes.json();
            const persons = await Promise.all(
              links.map((link) =>
                fetch(`/api/person-with-needs/${link.personId}`, {
                  headers: { Authorization: "Bearer " + jwt },
                })
                  .then((rr) => rr.json())
                  .then((pp) => ({
                    ...pp,
                    relationshipType: link.relationshipType,
                  }))
              )
            );
            setClients(persons);

            // 4) Clear form
            setNewPName("");
            setNewPDob("");
            setNewPMed("");
            setNewPBudgetType("Year");
            setNewPBudgetAmt("");
          } catch (err) {
            setAddErr(err.message || String(err));
          } finally {
            setAdding(false);
          }
        }

        async function loadAccessLinks(pid) {
          try {
            setAccessErr("");
            const r = await fetch(`/api/person-user-links/by-person/${pid}`, {
              headers: { Authorization: "Bearer " + jwt },
            });
            const d = await r.json();
            if (!r.ok) throw new Error(d.error || "Failed to load access list");
            setAccessLinks(d);
          } catch (e) {
            setAccessErr(e.message || String(e));
            setAccessLinks([]);
          }
        }

        async function revokeAccess(linkId) {
          try {
            const r = await fetch(`/api/person-user-links/${linkId}/revoke`, {
              method: "PATCH",
              headers: {
                "Content-Type": "application/json",
                Authorization: "Bearer " + jwt,
              },
            });
            const d = await r.json();
            if (!r.ok) throw new Error(d.error || "Failed to revoke");
            if (accessClientId) await loadAccessLinks(accessClientId);
          } catch (e) {
            alert("Error: " + (e.message || e));
          }
        }

        async function submitCareNeedItem(e) {
          e.preventDefault();
          setCiErr("");
          setCiSuccess("");
          setCiBusy(true);

          try {
            const jwt = localStorage.getItem("jwt");
            if (!jwt) throw new Error("UNAUTHENTICATED");

            if (!ciPersonId) throw new Error("Please select a client.");
            if (!ciName) throw new Error("Name is required.");

            const startDate =
              ciIntervalType === "JustPurchase"
                ? new Date() // today
                : new Date(ciStartDate);
            // Build payload
            const payload = {
              personId: ciPersonId,
              name: ciName,
              description: ciDesc,
              category: ciCategory,
              ...(ciUseCustomCat
                ? { newCategoryName: ciCustomCat }
                : { category: ciCategory }),
              frequency: {
                intervalType: ciIntervalType,
                intervalValue: Number(ciIntervalValue),
                startDate: startDate.toISOString(),
              },
              scheduleType: ciScheduleType, // NEW
              budgetCost: Number(ciBudgetCost) || 0,
              purchaseCost: Number(ciPurchaseCost) || 0,
              occurrenceCost: Number(ciOccurrenceCost) || 0,
            };

            if (ciScheduleType === "Timed") {
              payload.timeWindow = {
                startTime: ciStartTime,
                endTime: ciEndTime,
              };
            }

            if (ciEndMode === "endDate" && ciEndDate) {
              payload.endDate = new Date(ciEndDate).toISOString();
            }
            if (ciEndMode === "count" && ciOccurrenceCount) {
              payload.occurrenceCount = Number(ciOccurrenceCount);
            }

            // 1) Create CareNeedItem
            const r1 = await fetch("/api/care-need-items", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: "Bearer " + jwt,
              },
              body: JSON.stringify(payload),
            });
            const item = await r1.json();
            if (!r1.ok) throw new Error(item.error || "Failed to create item");

            const r2 = await fetch(
              `/api/scheduling/care-need-items/${item._id}/generate-tasks`,
              {
                method: "POST",
                headers: { Authorization: "Bearer " + jwt },
              }
            );
            const gen = await r2.json();
            if (!r2.ok)
              throw new Error(gen.error || "Failed to generate tasks");

            setCiSuccess(
              `Created item and generated ${gen.upserts || 0} tasks.`
            );
            // optional: clear form
            setCiName("");
            setCiDesc("");
            setCiUseCustomCat(false);
            setCiCustomCat("");
            setCiPurchaseCost(0);
            setCiOccurrenceCost(0);
            setCiBudgetCost(0);
            setCiIntervalType("Daily");
            setCiIntervalValue(1);
            setCiEndMode("none");
            setCiEndDate("");
            setCiOccurrenceCount("");
          } catch (err) {
            setCiErr(err.message || String(err));
          } finally {
            setCiBusy(false);
          }
        }

        // Format: "every N day/week/month/year" OR "one-time"
        function formatFrequency(freq) {
          if (!freq || !freq.intervalType) return "";
          if (freq.intervalType === "JustPurchase") {
            return "Just purchase (no recurrence)";
          }

          if (freq.intervalType === "OneTime") {
            // Optional: show the date if present
            const d = freq.startDate
              ? new Date(freq.startDate).toLocaleDateString()
              : "";
            return d ? `One-time (${d})` : "One-time";
          }
          const n = Number(freq.intervalValue || 1);
          const unit = freq.intervalType.toLowerCase(); // daily/weekly/monthly/yearly → day/week/month/year
          // normalize plural
          const singular =
            { daily: "day", weekly: "week", monthly: "month", yearly: "year" }[
              unit
            ] || unit;
          return `Every ${n} ${n === 1 ? singular : singular + "s"}`;
        }

        async function loadCareNeedItemsFor(personId) {
          try {
            setCniLoading(true);
            setCniErr("");
            setCniItems([]);
            const jwt = localStorage.getItem("jwt");
            if (!jwt) throw new Error("UNAUTHENTICATED");
            if (!personId) return;

            const r = await fetch(
              `/api/care-need-items?personId=${encodeURIComponent(personId)}`,
              {
                headers: { Authorization: "Bearer " + jwt },
              }
            );
            const d = await r.json();
            if (!r.ok) throw new Error(d.error || "Failed to load items");

            // Optional: sort by startDate or name
            d.sort((a, b) => {
              const as = a.frequency.startDate
                ? new Date(a.frequency.startDate).getTime()
                : 0;
              const bs = b.frequency.startDate
                ? new Date(b.frequency.startDate).getTime()
                : 0;
              return as - bs || a.name.localeCompare(b.name);
            });

            setCniItems(d);
          } catch (e) {
            setCniErr(e.message || String(e));
          } finally {
            setCniLoading(false);
          }
        }

        React.useEffect(() => {
          if (clients && clients.length > 0 && !cniClientId) {
            const first = clients[0]._id;
            setCniClientId(first);
            loadCareNeedItemsFor(first);
          }
          // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [clients]);

        async function loadTasksFor(personId) {
          try {
            setTasksLoading(true);
            setTasksErr("");
            const jwtNow = localStorage.getItem("jwt");
            if (!jwtNow) throw new Error("UNAUTHENTICATED");

            // Adjust the query as you like: add &status=Scheduled or date filters if your API supports them
            const r = await fetch(
              `/api/care-tasks?personId=${encodeURIComponent(
                personId
              )}&sort=dueDate`,
              {
                headers: { Authorization: "Bearer " + jwtNow },
              }
            );
            const data = await r.json();
            if (!r.ok) throw new Error(data.error || "Failed to load tasks");

            // Optional: sort client-side if server doesn’t
            data.sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate));
            setTasks(data);

            // Initialize cost editor visibility:
            // Completed + has cost  => hide editor
            // Completed + no cost   => show editor
            // Anything else         => hide editor (not completed)
            const hidden = {};
            const drafts = {};
            for (const t of data) {
              if (t.status === "Completed") {
                if (t.cost !== undefined && t.cost !== null) {
                  hidden[t._id] = true; // hide on load if it already has a saved cost
                } else {
                  hidden[t._id] = false; // show editor if completed but no cost yet
                }
              } else {
                hidden[t._id] = true; // not completed -> never show editor
              }
              drafts[t._id] = ""; // clear drafts on load
            }

            setCostEditorHiddenByTask(hidden);
            setCostDraftByTask(drafts);
          } catch (e) {
            setTasksErr(e.message || String(e));
            setTasks([]);
          } finally {
            setTasksLoading(false);
          }
        }
        // When clients change, pick default client for tasks
        React.useEffect(() => {
          if (clients && clients.length > 0) {
            const firstId = clients[0]._id;
            setTasksClientId(firstId);
            loadTasksFor(firstId);
          } else {
            setTasksClientId("");
            setTasks([]);
          }
        }, [clients]);

        function onChangeTasksClient(e) {
          const id = e.target.value;
          setTasksClientId(id);
          if (id) loadTasksFor(id);
        }

        async function toggleTaskComplete(task, checked) {
          try {
            const jwtNow = localStorage.getItem("jwt");
            if (!jwtNow) throw new Error("UNAUTHENTICATED");

            const body = checked
              ? { status: "Completed" }
              : { status: "Scheduled" };

            const r = await fetch(`/api/care-tasks/${task._id}`, {
              method: "PATCH",
              headers: {
                "Content-Type": "application/json",
                Authorization: "Bearer " + jwtNow,
              },
              body: JSON.stringify(body),
            });
            const d = await r.json();
            if (!r.ok) throw new Error(d.error || "Update failed");

            // Refresh tasks list
            if (tasksClientId) {
              await loadTasksFor(tasksClientId);
            }

            // visibility behavior:
            if (checked) {
              // just completed → show the editor
              setCostEditorHiddenByTask((prev) => ({
                ...prev,
                [task._id]: false,
              }));
              // optional: clear draft so user types fresh
              setCostDraftByTask((prev) => ({ ...prev, [task._id]: "" }));
            } else {
              // un-completed → next time it completes, show editor again
              setCostEditorHiddenByTask((prev) => ({
                ...prev,
                [task._id]: false,
              }));
            }

            if (tasksClientId) loadTasksFor(tasksClientId);
          } catch (e) {
            alert("Failed to update task: " + (e.message || e));
          }
        }

        async function loadComments(taskId) {
          const jwtNow = localStorage.getItem("jwt");
          if (!jwtNow) return;
          const r = await fetch(
            `/api/comments?careTaskId=${encodeURIComponent(taskId)}`,
            {
              headers: { Authorization: "Bearer " + jwtNow },
            }
          );
          const data = await r.json();
          if (!r.ok) throw new Error(data.error || "Failed to load comments");
          setCommentsByTask((prev) => ({
            ...prev,
            [taskId]: data.sort(
              (a, b) => new Date(a.createdAt) - new Date(b.createdAt)
            ),
          }));
        }

        async function addComment(taskId) {
          try {
            const jwtNow = localStorage.getItem("jwt");
            if (!jwtNow) throw new Error("UNAUTHENTICATED");
            if (!newCommentText.trim()) return;

            const r = await fetch(`/api/comments`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: "Bearer " + jwtNow,
              },
              body: JSON.stringify({
                careTaskId: taskId,
                text: newCommentText.trim(),
              }),
            });
            const d = await r.json();
            if (!r.ok) throw new Error(d.error || "Failed to add comment");

            setNewCommentText("");
            await loadComments(taskId);
          } catch (e) {
            alert("Failed to add comment: " + (e.message || e));
          }
        }

        async function loadFiles(taskId) {
          const jwtNow = localStorage.getItem("jwt");
          if (!jwtNow) return;
          const r = await fetch(
            `/api/file-upload?careTaskId=${encodeURIComponent(taskId)}`,
            {
              headers: { Authorization: "Bearer " + jwtNow },
            }
          );
          const data = await r.json();
          if (!r.ok) throw new Error(data.error || "Failed to load files");
          setFilesByTask((prev) => ({
            ...prev,
            [taskId]: data.sort(
              (a, b) => new Date(a.createdAt) - new Date(b.createdAt)
            ),
          }));
        }

        function resetNewFile() {
          setNewFile({
            filename: "",
            urlOrPath: "",
            fileType: "",
            size: "",
            description: "",
          });
        }

        async function addFile(taskId) {
          try {
            const jwtNow = localStorage.getItem("jwt");
            if (!jwtNow) throw new Error("UNAUTHENTICATED");
            if (!newFile.filename || !newFile.urlOrPath) {
              alert("Please provide filename and URL/path.");
              return;
            }
            const payload = {
              careTaskId: taskId,
              filename: newFile.filename,
              urlOrPath: newFile.urlOrPath,
              fileType: newFile.fileType || undefined,
              size: newFile.size ? Number(newFile.size) : undefined,
              description: newFile.description || undefined,
            };
            const r = await fetch(`/api/file-upload`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: "Bearer " + jwtNow,
              },
              body: JSON.stringify(payload),
            });
            const d = await r.json();
            if (!r.ok) throw new Error(d.error || "Failed to add file");

            resetNewFile();
            await loadFiles(taskId);
          } catch (e) {
            alert("Failed to add file: " + (e.message || e));
          }
        }

        function toggleComments(taskId) {
          if (openCommentsFor === taskId) {
            setOpenCommentsFor(null);
          } else {
            setOpenCommentsFor(taskId);
            loadComments(taskId);
          }
        }

        function toggleFiles(taskId) {
          if (openFilesFor === taskId) {
            setOpenFilesFor(null);
          } else {
            setOpenFilesFor(taskId);
            loadFiles(taskId);
          }
        }

        async function saveTaskCost(taskId) {
          try {
            const jwtNow = localStorage.getItem("jwt");
            if (!jwtNow) throw new Error("UNAUTHENTICATED");

            const raw = costDraftByTask[taskId];
            // Treat empty/undefined/null as 0
            const num =
              raw === "" || raw === undefined || raw === null ? 0 : Number(raw);

            if (Number.isNaN(num) || num < 0) {
              alert("Please enter a valid non-negative amount.");
              return;
            }

            const r = await fetch(`/api/care-tasks/${taskId}`, {
              method: "PATCH",
              headers: {
                "Content-Type": "application/json",
                Authorization: "Bearer " + jwtNow,
              },
              body: JSON.stringify({ cost: num }),
            });
            const d = await r.json();
            if (!r.ok) throw new Error(d.error || "Update failed");

            // hide editor until user unchecks & re-checks Completed
            setCostEditorHiddenByTask((prev) => ({ ...prev, [taskId]: true }));

            // optional: clear draft; displayed value will come from refreshed task
            setCostDraftByTask((prev) => ({ ...prev, [taskId]: "" }));

            if (tasksClientId) await loadTasksFor(tasksClientId);
          } catch (e) {
            alert("Failed to save cost: " + (e.message || String(e)));
          }
        }

        function toAnnualBudget(type, amt) {
          const n = Number(amt) || 0;
          if (type === "Week") return n * 52.15; // AU weeks per year ≈ 52.15
          if (type === "Month") return n * 12;
          return n; // Year
        }

        async function loadBudgetReport() {
          try {
            setReportErr("");
            setReport(null);
            const jwt = localStorage.getItem("jwt");
            if (!jwt) throw new Error("UNAUTHENTICATED");
            if (!reportClientId) throw new Error("Please choose a client");

            const r = await fetch(
              `/api/reports/budget?personId=${encodeURIComponent(
                reportClientId
              )}&year=${encodeURIComponent(reportYear)}`,
              {
                headers: { Authorization: "Bearer " + jwt },
              }
            );
            const d = await r.json();
            if (!r.ok) throw new Error(d.error || "Failed to load report");
            setReport(d);
          } catch (e) {
            setReportErr(e.message || String(e));
          }
        }

        // On dashboard load, mark past-due Scheduled tasks as Missed (server-side sweep)
        React.useEffect(() => {
          const jwtNow = localStorage.getItem("jwt");
          if (!jwtNow) return;
          fetch("/api/care-tasks/sweep-overdue", {
            method: "POST",
            headers: { Authorization: "Bearer " + jwtNow },
          })
            .then(() => {
              // after sweep, refresh current client's tasks
              if (tasksClientId) loadTasksFor(tasksClientId);
            })
            .catch(() => {});
        }, [tasksClientId]); // re-run when switching client to keep list fresh

        // Ensure rolling horizon for no-end items (org scoped / linked-scope for staff)
        React.useEffect(() => {
          const jwtNow = localStorage.getItem("jwt");
          if (!jwtNow) return;
          fetch("/api/scheduling/ensure-horizon?horizonDays=730", {
            method: "POST",
            headers: { Authorization: "Bearer " + jwtNow },
          })
            .then(() => {
              // reload current client's tasks after extending horizon
              if (tasksClientId) loadTasksFor(tasksClientId);
            })
            .catch(() => {});
        }, [tasksClientId]); // re-run when switching client to keep list fresh

        // Load categories when client is selected
        React.useEffect(() => {
          const jwt = localStorage.getItem("jwt");
          if (!jwt || !ciPersonId) return;

          fetch(`/api/person-with-needs/${ciPersonId}/categories`, {
            headers: { Authorization: "Bearer " + jwt },
          })
            .then((r) => r.json())
            .then((d) => {
              if (d && Array.isArray(d.categories)) {
                setCiCategories(d.categories);
                // if current ciCategory is not in list, keep it or reset:
                if (!d.categories.includes(ciCategory)) {
                  setCiCategory(d.categories[0] || "Other");
                }
              }
            })
            .catch(() => {
              /* ignore */
            });
        }, [ciPersonId]);

        return (
          <React.Fragment>
            <div className="card">
              <h2>
                Welcome, {(me && me.name) || ""}{" "}
                <span className="badge">{(me && me.role) || ""}</span>
              </h2>
              <p>
                {me && me.organizationId && (
                  <span>
                    Org: <code>{me.organizationId}</code> ·{" "}
                  </span>
                )}
                {(me && me.email) || ""}
              </p>

              {/* Leave organisation button only for Admin or Staff */}
              {me &&
                (me.role === "Admin" || me.role === "GeneralCareStaff") &&
                me.organizationId && (
                  <button
                    className="secondary"
                    onClick={async () => {
                      try {
                        const jwt = localStorage.getItem("jwt");
                        if (!jwt) throw new Error("UNAUTHENTICATED");

                        const r = await fetch(
                          "/api/users/me/leave-organization",
                          {
                            method: "PATCH",
                            headers: {
                              "Content-Type": "application/json",
                              Authorization: "Bearer " + jwt,
                            },
                          }
                        );
                        const d = await r.json();
                        if (!r.ok) throw new Error(d.error || "Failed");

                        alert("You left the organisation successfully.");
                        // Refresh auth/me
                        const rr = await fetch("/api/auth/me", {
                          headers: { Authorization: "Bearer " + jwt },
                        });
                        const dd = await rr.json();
                        if (rr.ok) {
                          refreshMe();
                        }
                      } catch (e) {
                        alert(
                          "Error leaving organisation: " + (e.message || e)
                        );
                      }
                    }}
                  >
                    Leave organization
                  </button>
                )}

              <button className="secondary" onClick={onLogout}>
                Log out
              </button>
            </div>

            {me && (me.role === "Family" || me.role === "PoA") && (
              <div className="card">
                <h3>Your organisation</h3>
                <OrgBadge me={me} />
                <div className="row">
                  <div>
                    <input
                      placeholder="Organisation ID"
                      value={pendingOrgId}
                      onChange={(e) => setPendingOrgId(e.target.value)}
                    />
                  </div>
                  <div>
                    <button
                      className="secondary"
                      onClick={async () => {
                        try {
                          setOrgSaveMsg("");
                          if (!pendingOrgId) {
                            setOrgSaveMsg("Please enter an organisation ID.");
                            return;
                          }

                          // If Family/PoA, ask whether to cascade move clients
                          let migrateClients = false;
                          if (me.role === "Family" || me.role === "PoA") {
                            migrateClients = window.confirm(
                              "Also move ALL your clients to the new organisation, move other Family/PoA linked to those clients, update all items/tasks, and revoke all staff/admin access on those clients?\n\nClick OK to proceed."
                            );
                          }

                          const r = await fetch("/api/users/me/organization", {
                            method: "PATCH",
                            headers: {
                              "Content-Type": "application/json",
                              Authorization: "Bearer " + jwt,
                            },
                            body: JSON.stringify({
                              organizationId: pendingOrgId,
                              migrateClients,
                            }),
                          });
                          const d = await r.json();
                          if (!r.ok)
                            throw new Error(
                              d.error || "Failed to save organisation"
                            );

                          setOrgSaveMsg("Saved.");

                          // Show a quick summary if cascade ran
                          if (d.cascade) {
                            const c = d.cascade;
                            setOrgSaveMsg(
                              `Saved. Moved Persons: ${c.personsMoved}, Items: ${c.itemsMoved}, Tasks: ${c.tasksMoved}, Family/PoA moved: ${c.familyMoved}, Staff/Admin links revoked: ${c.staffRevoked}.`
                            );
                          }

                          // Refresh current user (so org updates immediately)
                          const rr = await fetch("/api/auth/me", {
                            headers: { Authorization: "Bearer " + jwt },
                          });
                          const dd = await rr.json();
                          // If your App passes setMe down, call setMe(dd.user); or fallback to reload:
                          // window.location.reload();
                        } catch (e) {
                          setOrgSaveMsg("Error: " + (e.message || e));
                        }
                      }}
                    >
                      Save
                    </button>
                  </div>
                </div>
                {orgSaveMsg && <p>{orgSaveMsg}</p>}
                {!me.organizationId && (
                  <p style={{ color: "#92400e" }}>
                    You must set your organisation before adding a client.
                  </p>
                )}
              </div>
            )}

            {me && (me.role === "Admin" || me.role === "GeneralCareStaff") && (
              <div className="card">
                <h3>Request access with a token</h3>
                <p>
                  Paste the invite token you received, add an optional message,
                  and request access. The issuer will review and approve.
                </p>
                <input
                  placeholder="Invite token"
                  value={token}
                  onChange={(e) => setToken(e.target.value)}
                />
                <input
                  placeholder="Optional message"
                  value={reqMsg}
                  onChange={(e) => setReqMsg(e.target.value)}
                />
                <button
                  onClick={async () => {
                    try {
                      setReqFeedback("");
                      // optionally: call /tokens/verify first to give immediate feedback about type/org
                      const r = await fetch("/api/access-requests", {
                        method: "POST",
                        headers: {
                          "Content-Type": "application/json",
                          Authorization: "Bearer " + jwt,
                        },
                        body: JSON.stringify({ token, message: reqMsg }),
                      });
                      const d = await r.json();
                      if (!r.ok)
                        throw new Error(d.error || "Failed to submit request");
                      setReqFeedback("Request submitted. Await approval.");
                      setToken("");
                      setReqMsg("");
                    } catch (e) {
                      setReqFeedback("Error: " + (e.message || e));
                    }
                  }}
                >
                  Request access
                </button>
                {reqFeedback && <p>{reqFeedback}</p>}
              </div>
            )}

            {me &&
              (me.role === "Admin" ||
                me.role === "Family" ||
                me.role === "PoA") && (
                <div className="card">
                  <h3>Create invite token</h3>
                  <label>Type</label>
                  <select
                    value={type}
                    onChange={(e) => setType(e.target.value)}
                  >
                    {allowedTypesFor(me.role).map(([v, label]) => (
                      <option key={v} value={v}>
                        {label}
                      </option>
                    ))}
                  </select>

                  <label>Organization ID</label>
                  <input value={organizationId} disabled />

                  <label>Client (required)</label>
                  <select
                    value={selectedPersonId}
                    onChange={(e) => setSelectedPersonId(e.target.value)}
                  >
                    <option value="">— Select a client —</option>
                    {clients.map((c) => (
                      <option key={c._id} value={c._id}>
                        {c.name}
                      </option>
                    ))}
                  </select>

                  <div className="row">
                    <div>
                      <label>Expires in (days)</label>
                      <input
                        type="number"
                        min="1"
                        value={expiresInDays}
                        onChange={(e) => setExpiresInDays(e.target.value)}
                      />
                    </div>
                    <div>
                      <label>Max uses</label>
                      <input
                        type="number"
                        min="1"
                        max="15"
                        value={maxUses}
                        onChange={(e) => setMaxUses(e.target.value)}
                      />
                    </div>
                  </div>

                  <button onClick={createToken} disabled={!selectedPersonId}>
                    Create token
                  </button>
                  {tokenResult &&
                    (tokenResult.token ? (
                      <p>
                        Share code: <code>{tokenResult.token}</code> (expires{" "}
                        {new Date(tokenResult.expiresAt).toLocaleString()})
                      </p>
                    ) : (
                      <p style={{ color: "#b91c1c" }}>
                        Error: {tokenResult.error}
                      </p>
                    ))}
                </div>
              )}

            {me &&
              (me.role === "Family" ||
                me.role === "PoA" ||
                me.role === "Admin") && <IncomingAccessRequests jwt={jwt} />}

            {me && me.role === "Family" && (
              <div className="card">
                <h3>Add a client (PWSN)</h3>
                <form onSubmit={addClient}>
                  <input
                    placeholder="Client name"
                    value={newPName}
                    onChange={(e) => setNewPName(e.target.value)}
                  />
                  <div className="row">
                    <div>
                      <label>Date of birth</label>
                      <input
                        type="date"
                        value={newPDob}
                        onChange={(e) => setNewPDob(e.target.value)}
                      />
                    </div>
                    <div>
                      <label>Medical info (optional)</label>
                      <input
                        value={newPMed}
                        onChange={(e) => setNewPMed(e.target.value)}
                        placeholder="e.g., allergies, notes..."
                      />
                    </div>
                  </div>

                  <div className="row">
                    <div>
                      <label>Budget period</label>
                      <select
                        value={newPBudgetType}
                        onChange={(e) => setNewPBudgetType(e.target.value)}
                      >
                        <option>Year</option>
                        <option>Month</option>
                        <option>Week</option>
                      </select>
                    </div>
                    <div>
                      <label>Budget amount (AUD)</label>
                      <input
                        type="number"
                        min="0"
                        step="0.01"
                        value={newPBudgetAmt}
                        onChange={(e) => setNewPBudgetAmt(e.target.value)}
                      />
                    </div>
                  </div>

                  <p style={{ opacity: 0.7 }}>
                    Annual budget will be saved as:{" "}
                    <strong>
                      {new Intl.NumberFormat("en-AU", {
                        style: "currency",
                        currency: "AUD",
                      }).format(toAnnualBudget(newPBudgetType, newPBudgetAmt))}
                    </strong>
                  </p>

                  <button disabled={adding}>
                    {adding ? "Adding..." : "Add client"}
                  </button>
                  {addErr && (
                    <p style={{ color: "#b91c1c" }}>Error: {addErr}</p>
                  )}
                  <p className="badge">
                    Org derived from your account:{" "}
                    <code>{(me && me.organizationId) || ""}</code>
                  </p>
                </form>
              </div>
            )}

            <div className="card">
              <h3>My Clients</h3>
              {clients.length === 0 ? (
                <p>No linked clients.</p>
              ) : (
                <ul>
                  {clients.map((c) => (
                    <li key={c._id}>
                      <strong>{c.name}</strong> ({c.relationshipType})
                      {c.dateOfBirth && (
                        <span>
                          {" "}
                          · DOB {new Date(c.dateOfBirth).toLocaleDateString()}
                        </span>
                      )}
                      {c.status && <span> · Status {c.status}</span>}
                    </li>
                  ))}
                </ul>
              )}
            </div>

            {me &&
              (me.role === "Family" ||
                me.role === "PoA" ||
                me.role === "Admin") && (
                <div className="card">
                  <h3>Client Access Management</h3>
                  <label>Select client</label>
                  <select
                    value={accessClientId}
                    onChange={(e) => {
                      setAccessClientId(e.target.value);
                      if (e.target.value) loadAccessLinks(e.target.value);
                    }}
                  >
                    <option value="">— Choose client —</option>
                    {clients.map((c) => (
                      <option key={c._id} value={c._id}>
                        {c.name}
                      </option>
                    ))}
                  </select>

                  {accessErr && (
                    <p style={{ color: "#b91c1c" }}>Error: {accessErr}</p>
                  )}
                  {!accessClientId && (
                    <p>Select a client to see associated users.</p>
                  )}

                  {accessClientId && accessLinks.length > 0 && (
                    <table
                      style={{
                        width: "100%",
                        marginTop: 12,
                        borderCollapse: "collapse",
                      }}
                    >
                      <thead>
                        <tr>
                          <th align="left">Name</th>
                          <th align="left">Email</th>
                          <th align="left">Role</th>
                          <th>Action</th>
                        </tr>
                      </thead>
                      <tbody>
                        {accessLinks.map((l) => {
                          const u = l.userId;
                          // Hide users depending on current viewer's role
                          if (me.role === "Family" || me.role === "PoA") {
                            // Family/PoA can see everyone
                            if (me.id === u._id) {
                              // but not themselves
                              return null;
                            }
                          } else if (me.role === "Admin") {
                            // Admin should only see staff
                            if (u.role !== "GeneralCareStaff") return null;
                          } else {
                            return null;
                          }

                          return (
                            <tr key={l._id}>
                              <td>{u.name}</td>
                              <td>{u.email}</td>
                              <td>{u.role}</td>
                              <td>
                                <button
                                  className="secondary"
                                  onClick={() => revokeAccess(l._id)}
                                >
                                  Revoke
                                </button>
                              </td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  )}

                  {accessClientId && accessLinks.length === 0 && (
                    <p>No associated users yet.</p>
                  )}
                </div>
              )}

            {me && (me.role === "Family" || me.role === "Admin") && (
              <div className="card">
                <h3>Create Care Need Item</h3>
                <form onSubmit={submitCareNeedItem}>
                  <label>Client</label>
                  <select
                    value={ciPersonId}
                    onChange={(e) => setCiPersonId(e.target.value)}
                  >
                    <option value="">— Select a client —</option>
                    {clients.map((c) => (
                      <option key={c._id} value={c._id}>
                        {c.name}
                      </option>
                    ))}
                  </select>

                  <div className="row">
                    <div>
                      <label>Name</label>
                      <input
                        value={ciName}
                        onChange={(e) => setCiName(e.target.value)}
                        placeholder="e.g., Dental visit"
                      />
                    </div>

                    <div>
                      <label>Category</label>
                      {!ciUseCustomCat ? (
                        <React.Fragment>
                          <select
                            value={ciCategory}
                            onChange={(e) => setCiCategory(e.target.value)}
                          >
                            {ciCategories.map((cat) => (
                              <option key={cat} value={cat}>
                                {cat}
                              </option>
                            ))}
                          </select>
                          <button
                            type="button"
                            className="secondary"
                            onClick={() => {
                              setCiUseCustomCat(true);
                              setCiCustomCat("");
                            }}
                            style={{ marginTop: 6 }}
                          >
                            + Add custom
                          </button>
                        </React.Fragment>
                      ) : (
                        <React.Fragment>
                          <input
                            placeholder="Type new category"
                            value={ciCustomCat}
                            onChange={(e) => setCiCustomCat(e.target.value)}
                          />
                          <div style={{ display: "flex", gap: 8 }}>
                            <button
                              type="button"
                              className="secondary"
                              onClick={() => setCiUseCustomCat(false)}
                            >
                              Use list instead
                            </button>
                          </div>
                        </React.Fragment>
                      )}
                    </div>
                  </div>

                  <label>Description</label>
                  <input
                    value={ciDesc}
                    onChange={(e) => setCiDesc(e.target.value)}
                    placeholder="Optional notes"
                  />

                  <div className="row">
                    <div>
                      <label>Interval Type</label>
                      <select
                        value={ciIntervalType}
                        onChange={(e) => setCiIntervalType(e.target.value)}
                      >
                        <option value="JustPurchase">Just Purchase</option>
                        <option value="OneTime">One Time</option>
                        <option value="Daily">Daily</option>
                        <option value="Weekly">Weekly</option>
                        <option value="Monthly">Monthly</option>
                        <option value="Yearly">Yearly</option>
                      </select>
                    </div>
                    {ciIntervalType !== "OneTime" &&
                      ciIntervalType !== "JustPurchase" && (
                        <div>
                          <label>Every N (interval value)</label>
                          <input
                            type="number"
                            min="1"
                            value={ciIntervalValue}
                            onChange={(e) => setCiIntervalValue(e.target.value)}
                          />
                        </div>
                      )}
                  </div>

                  {ciIntervalType !== "JustPurchase" && (
                    <div className="row">
                      <div>
                        <label>Start date</label>
                        <input
                          type="date"
                          value={ciStartDate}
                          onChange={(e) => setCiStartDate(e.target.value)}
                        />
                      </div>
                      {ciIntervalType !== "OneTime" && (
                        <div>
                          <label>End condition</label>
                          <select
                            value={ciEndMode}
                            onChange={(e) => setCiEndMode(e.target.value)}
                          >
                            <option value="none">No end</option>
                            <option value="endDate">End by date</option>
                            <option value="count">
                              End after N occurrences
                            </option>
                          </select>
                        </div>
                      )}
                    </div>
                  )}

                  {ciEndMode === "endDate" && (
                    <div>
                      <label>End date</label>
                      <input
                        type="date"
                        value={ciEndDate}
                        onChange={(e) => setCiEndDate(e.target.value)}
                      />
                    </div>
                  )}
                  {ciEndMode === "count" && (
                    <div>
                      <label>Occurrences</label>
                      <input
                        type="number"
                        min="1"
                        value={ciOccurrenceCount}
                        onChange={(e) => setCiOccurrenceCount(e.target.value)}
                      />
                    </div>
                  )}

                  {ciIntervalType !== "JustPurchase" && (
                    <div className="row">
                      <div>
                        <label>Schedule type</label>
                        <select
                          value={ciScheduleType}
                          onChange={(e) => setCiScheduleType(e.target.value)}
                        >
                          <option value="AllDay">All-day</option>
                          <option value="Timed">Scheduled (start/end)</option>
                        </select>
                      </div>

                      {ciScheduleType === "Timed" && (
                        <div>
                          <label>Start time / End time</label>
                          <div className="row">
                            <input
                              type="time"
                              value={ciStartTime}
                              onChange={(e) => setCiStartTime(e.target.value)}
                            />
                            <input
                              type="time"
                              value={ciEndTime}
                              onChange={(e) => setCiEndTime(e.target.value)}
                            />
                          </div>
                        </div>
                      )}
                    </div>
                  )}

                  <div className="row">
                    <div>
                      <label>Budget (AUD)</label>
                      <input
                        type="number"
                        min="0"
                        step="0.01"
                        value={ciBudgetCost !== 0 ? ciBudgetCost : ""}
                        onChange={(e) => setCiBudgetCost(e.target.value)}
                        placeholder="0.00"
                      />
                    </div>
                  </div>

                  <div className="row">
                    <div>
                      <label>Purchase cost (AUD)</label>
                      <input
                        type="number"
                        min="0"
                        step="0.01"
                        value={ciPurchaseCost !== 0 ? ciPurchaseCost : ""}
                        onChange={(e) => setCiPurchaseCost(e.target.value)}
                        placeholder="0.00"
                      />
                    </div>
                    {ciIntervalType !== "JustPurchase" && (
                      <div>
                        <label>Expected occurrence cost per task (AUD)</label>
                        <input
                          type="number"
                          min="0"
                          step="0.01"
                          value={ciOccurrenceCost !== 0 ? ciOccurrenceCost : ""}
                          onChange={(e) => setCiOccurrenceCost(e.target.value)}
                          placeholder="0.00"
                        />
                      </div>
                    )}
                  </div>

                  <button disabled={ciBusy}>
                    {ciBusy ? "Saving..." : "Create & Generate"}
                  </button>
                  {ciErr && <p style={{ color: "#b91c1c" }}>Error: {ciErr}</p>}
                  {ciSuccess && <p style={{ color: "#065f46" }}>{ciSuccess}</p>}
                </form>
              </div>
            )}

            <div className="card">
              <h3>Care Need Items</h3>
              <div className="row">
                <div>
                  <label>Client</label>
                  <select
                    value={cniClientId}
                    onChange={(e) => {
                      const v = e.target.value;
                      setCniClientId(v);
                      if (v) loadCareNeedItemsFor(v);
                    }}
                  >
                    <option value="">— Select client —</option>
                    {clients.map((c) => (
                      <option key={c._id} value={c._id}>
                        {c.name}
                      </option>
                    ))}
                  </select>
                </div>
                <div>
                  <label>&nbsp;</label>
                  <button
                    className="secondary"
                    onClick={() =>
                      cniClientId && loadCareNeedItemsFor(cniClientId)
                    }
                  >
                    Refresh
                  </button>
                </div>
              </div>

              {cniErr && <p style={{ color: "#b91c1c" }}>Error: {cniErr}</p>}
              {cniLoading && <p>Loading items…</p>}

              {!cniLoading && cniItems.length === 0 && (
                <p>No care need items for this client.</p>
              )}

              {cniItems.length > 0 && (
                <table style={{ width: "100%", borderCollapse: "collapse" }}>
                  <thead>
                    <tr>
                      <th style={{ textAlign: "left" }}>Name</th>
                      <th style={{ textAlign: "left" }}>Frequency</th>
                      <th style={{ textAlign: "left" }}>Budget</th>
                      <th style={{ textAlign: "left" }}>Purchase cost</th>
                      <th style={{ textAlign: "left" }}>Expected per task</th>
                      <th style={{ textAlign: "left" }}>Schedule</th>
                      <th style={{ textAlign: "left" }}>Category</th>
                    </tr>
                  </thead>
                  <tbody>
                    {cniItems.map((it) => (
                      <tr key={it._id} style={{ borderTop: "1px solid #eee" }}>
                        <td>{it.name}</td>
                        <td>{formatFrequency(it.frequency)}</td>
                        <td style={{ textAlign: "left" }}>
                          {new Intl.NumberFormat("en-AU", {
                            style: "currency",
                            currency: "AUD",
                          }).format(it.budgetCost || 0)}
                        </td>
                        <td style={{ textAlign: "left" }}>
                          {new Intl.NumberFormat("en-AU", {
                            style: "currency",
                            currency: "AUD",
                          }).format(it.purchaseCost || 0)}
                        </td>
                        <td style={{ textAlign: "left" }}>
                          {new Intl.NumberFormat("en-AU", {
                            style: "currency",
                            currency: "AUD",
                          }).format(it.occurrenceCost || 0)}
                        </td>
                        <td>
                          <span className="badge">
                            {it.scheduleType === "Timed" && it.timeWindow
                              ? `Scheduled ${it.timeWindow.startTime}–${it.timeWindow.endTime}`
                              : "All-day"}
                          </span>
                        </td>
                        <td>{it.category}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              )}
            </div>

            <div className="card">
              <h3>My Tasks</h3>

              {/* Client picker shows only if you have more than one client */}
              {clients.length > 1 && (
                <div>
                  <label>Client</label>
                  <select value={tasksClientId} onChange={onChangeTasksClient}>
                    {clients.map((c) => (
                      <option key={c._id} value={c._id}>
                        {c.name}
                      </option>
                    ))}
                  </select>
                </div>
              )}

              {/* If only one client, show its name */}
              {clients.length === 1 && (
                <p>
                  Client: <strong>{clients[0].name}</strong>
                </p>
              )}

              {tasksLoading && <p>Loading…</p>}
              {tasksErr && (
                <p style={{ color: "#b91c1c" }}>Error: {tasksErr}</p>
              )}

              {!tasksLoading && !tasksErr && tasks.length === 0 && (
                <p>No tasks found for this client.</p>
              )}

              {!tasksLoading && !tasksErr && tasks.length > 0 && (
                <ul>
                  {tasks.map((t) => (
                    <li key={t._id}>
                      <div>
                        <div style={{ display: "inline", marginLeft: 8 }}>
                          <strong>{t.title}</strong>
                          {" · "}
                          {new Date(t.dueDate).toLocaleDateString()}

                          {t.scheduleType === "Timed" &&
                            t.startAt &&
                            t.endAt && (
                              <React.Fragment>
                                {" · "}
                                {new Date(t.startAt).toLocaleTimeString([], {
                                  hour: "2-digit",
                                  minute: "2-digit",
                                })}
                                {" – "}
                                {new Date(t.endAt).toLocaleTimeString([], {
                                  hour: "2-digit",
                                  minute: "2-digit",
                                })}
                              </React.Fragment>
                            )}
                          {" · "}
                          <span className="badge">
                            {t.scheduleType === "AllDay" ? "All-day" : "Timed"}
                          </span>
                          {" · "}
                          <span className="badge">{t.status}</span>
                          <input
                            style={{
                              display: "inline",
                              width: "auto",
                              marginLeft: 16,
                            }}
                            type="checkbox"
                            checked={t.status === "Completed"}
                            onChange={(e) =>
                              toggleTaskComplete(t, e.target.checked)
                            }
                            title={
                              t.status === "Completed"
                                ? "Unmark as completed"
                                : "Mark as completed"
                            }
                          />
                          {/* Show spent amount (read-only) if present */}
                          {t.status === "Completed" &&
                            t.cost !== undefined &&
                            t.cost !== null && (
                              <React.Fragment>
                                {" · "}Spent:{" "}
                                <strong>{aud.format(t.cost)}</strong>{" "}
                                <button
                                  className="secondary"
                                  style={{
                                    marginTop: 8,
                                    borderRadius: 8,
                                    padding: 10,
                                  }}
                                  onClick={() => {
                                    // reopen editor & prefill with current cost (or 0)
                                    setCostEditorHiddenByTask((prev) => ({
                                      ...prev,
                                      [t._id]: false,
                                    }));
                                    setCostDraftByTask((prev) => ({
                                      ...prev,
                                      [t._id]:
                                        t.cost !== undefined && t.cost !== null
                                          ? String(t.cost) // keep as string for input
                                          : "0",
                                    }));
                                  }}
                                >
                                  Change cost
                                </button>
                              </React.Fragment>
                            )}
                        </div>

                        <button
                          className="secondary"
                          onClick={() => toggleComments(t._id)}
                        >
                          Comments
                        </button>
                        <button
                          className="secondary"
                          onClick={() => toggleFiles(t._id)}
                        >
                          Files
                        </button>
                      </div>

                      {/* Cost entry appears ONLY when completed and editor not hidden */}
                      {t.status === "Completed" &&
                        !costEditorHiddenByTask[t._id] && (
                          <div
                            style={{
                              marginTop: 8,
                              display: "flex",
                              alignItems: "center",
                              gap: 8,
                            }}
                          >
                            <label style={{ minWidth: 120 }}>
                              Budget spent (AUD)
                            </label>
                            <input
                              type="number"
                              min="0"
                              step="0.01"
                              placeholder="0.00"
                              value={
                                costDraftByTask[t._id] !== undefined
                                  ? costDraftByTask[t._id]
                                  : t.cost !== undefined && t.cost !== null
                                  ? t.cost
                                  : 0
                              }
                              onChange={(e) =>
                                setCostDraftByTask((prev) => ({
                                  ...prev,
                                  [t._id]: e.target.value,
                                }))
                              }
                              style={{ maxWidth: 160 }}
                            />
                            <button onClick={() => saveTaskCost(t._id)}>
                              Save
                            </button>
                          </div>
                        )}

                      {/* Cost entry appears ONLY when completed, no cost yet, and not hidden */}

                      {/* Comments panel */}
                      {openCommentsFor === t._id && (
                        <div
                          style={{
                            marginTop: 8,
                            background: "#fafafa",
                            borderRadius: 8,
                            padding: 8,
                          }}
                        >
                          <h4 style={{ margin: "4px 0" }}>Comments</h4>
                          <div>
                            {(commentsByTask[t._id] || []).length === 0 ? (
                              <p>No comments yet.</p>
                            ) : (
                              <ul>
                                {(commentsByTask[t._id] || []).map((c) => (
                                  <li key={c._id}>
                                    <strong>
                                      {(c.author &&
                                        (c.author.name || c.author.email)) ||
                                        "Unknown"}
                                    </strong>
                                    {" · "}
                                    {new Date(c.createdAt).toLocaleString()}
                                    <div>{c.text}</div>
                                  </li>
                                ))}
                              </ul>
                            )}
                          </div>
                          <div className="row">
                            <input
                              placeholder="Write a comment…"
                              value={newCommentText}
                              onChange={(e) =>
                                setNewCommentText(e.target.value)
                              }
                            />
                            <button onClick={() => addComment(t._id)}>
                              Add
                            </button>
                          </div>
                        </div>
                      )}

                      {/* Files panel */}
                      {openFilesFor === t._id && (
                        <div
                          style={{
                            marginTop: 8,
                            background: "#fafafa",
                            borderRadius: 8,
                            padding: 8,
                          }}
                        >
                          <h4 style={{ margin: "4px 0" }}>Files</h4>

                          {/* Existing list */}
                          <div>
                            {(filesByTask[t._id] || []).length === 0 ? (
                              <p>No files yet.</p>
                            ) : (
                              <ul>
                                {(filesByTask[t._id] || []).map((f) => (
                                  <li key={f._id} style={{ marginBottom: 6 }}>
                                    {/* small thumbnail for images */}
                                    {f.fileType &&
                                    f.fileType.startsWith("image/") ? (
                                      <a
                                        href={f.urlOrPath}
                                        target="_blank"
                                        rel="noreferrer"
                                      >
                                        <img
                                          src={f.urlOrPath}
                                          alt={f.filename}
                                          style={{
                                            maxHeight: 64,
                                            maxWidth: 96,
                                            objectFit: "cover",
                                            marginRight: 8,
                                            verticalAlign: "middle",
                                            borderRadius: 4,
                                            border: "1px solid #ddd",
                                          }}
                                        />
                                      </a>
                                    ) : (
                                      <a
                                        href={f.urlOrPath}
                                        target="_blank"
                                        rel="noreferrer"
                                      >
                                        {f.filename}
                                      </a>
                                    )}
                                    {" · "}
                                    {new Date(f.createdAt).toLocaleString()}
                                    {f.description ? (
                                      <div>{f.description}</div>
                                    ) : null}
                                  </li>
                                ))}
                              </ul>
                            )}
                          </div>

                          {/* --- Link mode (kept) --- */}
                          <h5>Add by link</h5>
                          <div className="row">
                            <input
                              placeholder="Filename (e.g., Pyjamas photo)"
                              value={newFile.filename}
                              onChange={(e) =>
                                setNewFile((prev) => ({
                                  ...prev,
                                  filename: e.target.value,
                                }))
                              }
                            />
                            <input
                              placeholder="URL or path (https://…)"
                              value={newFile.urlOrPath}
                              onChange={(e) =>
                                setNewFile((prev) => ({
                                  ...prev,
                                  urlOrPath: e.target.value,
                                }))
                              }
                            />
                          </div>

                          <input
                            placeholder="Description (optional)"
                            value={newFile.description}
                            onChange={(e) =>
                              setNewFile((prev) => ({
                                ...prev,
                                description: e.target.value,
                              }))
                            }
                          />
                          <button onClick={() => addFile(t._id)}>
                            Add file (link)
                          </button>

                          {/* --- Real upload (new) --- */}
                          <h5 style={{ marginTop: 12 }}>Upload a file</h5>
                          <form
                            onSubmit={async (e) => {
                              e.preventDefault();
                              const form = e.currentTarget; // <-- keep a real DOM ref
                              try {
                                const jwtNow = localStorage.getItem("jwt");
                                if (!jwtNow) throw new Error("UNAUTHENTICATED");

                                const fd = new FormData(form); // build before awaits is fine too
                                fd.set("careTaskId", t._id); // ensure task id included

                                const r = await fetch(
                                  "/api/file-upload/upload",
                                  {
                                    method: "POST",
                                    headers: {
                                      Authorization: "Bearer " + jwtNow,
                                    }, // DON'T set Content-Type
                                    body: fd,
                                  }
                                );

                                // Be robust to non-JSON errors
                                const isJson = r.headers
                                  .get("content-type")
                                  .includes("application/json");
                                const data = isJson
                                  ? await r.json()
                                  : { error: await r.text() };

                                if (!r.ok)
                                  throw new Error(
                                    data.error || "Upload failed"
                                  );

                                form.reset(); // <-- safe now
                                await loadFiles(t._id);
                              } catch (err) {
                                alert(
                                  "Upload failed: " +
                                    (err.message || String(err))
                                );
                              }
                            }}
                          >
                            <input type="file" name="file" required />
                            <input
                              name="description"
                              placeholder="Description (optional)"
                            />
                            <button type="submit">Upload</button>
                          </form>
                        </div>
                      )}
                    </li>
                  ))}
                </ul>
              )}
            </div>

            <div className="card">
              <h3>Budget Reporting</h3>
              <div className="row">
                <div>
                  <label>Client</label>
                  <select
                    value={reportClientId}
                    onChange={(e) => setReportClientId(e.target.value)}
                  >
                    <option value="">— Select client —</option>
                    {clients.map((c) => (
                      <option key={c._id} value={c._id}>
                        {c.name}
                      </option>
                    ))}
                  </select>
                </div>
                <div>
                  <label>Year</label>
                  <input
                    type="number"
                    min="2000"
                    max="2100"
                    value={reportYear}
                    onChange={(e) => setReportYear(Number(e.target.value))}
                  />
                </div>
              </div>
              <button onClick={loadBudgetReport}>Run report</button>
              {reportErr && (
                <p style={{ color: "#b91c1c" }}>Error: {reportErr}</p>
              )}

              {report && (
                <div style={{ marginTop: 12 }}>
                  <p>
                    <strong>Annual budget:</strong>{" "}
                    {aud.format(report.annualBudget)}
                    <br />
                    <strong>Already spent:</strong>{" "}
                    {aud.format(report.spent.total)}{" "}
                    <span style={{ opacity: 0.7 }}>
                      (purchase {aud.format(report.spent.purchase)} + completed
                      tasks {aud.format(report.spent.completed)})
                    </span>
                    <br />
                    <strong>Current balance:</strong>{" "}
                    {aud.format(report.balance.current)}
                    <br />
                    <strong>
                      Expected remaining (uncompleted tasks):
                    </strong>{" "}
                    {aud.format(report.expected.remaining)}
                    <br />
                    <strong>Expected balance at year end:</strong>{" "}
                    {aud.format(report.balance.expectedAtYearEnd)}
                  </p>

                  <h4>By category</h4>
                  {report.categories.length === 0 ? (
                    <p>No category data.</p>
                  ) : (
                    <table
                      style={{ width: "100%", borderCollapse: "collapse" }}
                    >
                      <thead>
                        <tr>
                          <th style={{ textAlign: "left" }}>Category</th>
                          <th style={{ textAlign: "right" }}>Annual Budget</th>
                          <th style={{ textAlign: "right" }}>Already Spent</th>
                          <th style={{ textAlign: "right" }}>
                            Current Balance
                          </th>
                          <th style={{ textAlign: "right" }}>
                            Expected Remaining
                          </th>
                          <th style={{ textAlign: "right" }}>
                            Expected Balance
                          </th>
                          <th style={{ textAlign: "right" }}>% Spent</th>
                          <th style={{ textAlign: "right" }}>% Expected</th>
                        </tr>
                      </thead>
                      <tbody>
                        {report.categories.map((c) => (
                          <tr key={c.category}>
                            <td>{c.category}</td>
                            <td style={{ textAlign: "right" }}>
                              {aud.format(c.annualBudget || 0)}
                            </td>
                            <td style={{ textAlign: "right" }}>
                              {aud.format(c.totalSpent || 0)}
                            </td>
                            <td style={{ textAlign: "right" }}>
                              {aud.format(c.currentBalance || 0)}
                            </td>
                            <td style={{ textAlign: "right" }}>
                              {aud.format(c.expected || 0)}
                            </td>
                            <td style={{ textAlign: "right" }}>
                              {aud.format(c.expectedBalanceAtYearEnd || 0)}
                            </td>
                            <td style={{ textAlign: "right" }}>
                              {((c.spentPct || 0) * 100).toFixed(1)}%
                            </td>
                            <td style={{ textAlign: "right" }}>
                              {((c.expectedPct || 0) * 100).toFixed(1)}%
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  )}
                </div>
              )}
            </div>

            <div className="card">
              <h3>Recent tokens</h3>
              {list.length === 0 ? (
                <p>No tokens yet.</p>
              ) : (
                <ul>
                  {list.map((t) => (
                    <li key={t._id}>
                      <span className="badge">{t.type}</span> · uses {t.uses}/
                      {t.maxUses} · expires{" "}
                      {new Date(t.expiresAt).toLocaleDateString()}
                    </li>
                  ))}
                </ul>
              )}
            </div>
          </React.Fragment>
        );
      }

      function App() {
        const [me, setMe] = useAuth();
        const [page, setPage] = React.useState("login");

        React.useEffect(() => {
          const bind = (id, p) => {
            document.getElementById(id).onclick = (e) => {
              e.preventDefault();
              setPage(p);
            };
          };
          bind("nav-login", "login");
          bind("nav-register", "register");
          bind("nav-dashboard", "dashboard");
        }, []);

        function onAuthed(user) {
          setMe(user);
          setPage("dashboard");
        }
        function logout() {
          localStorage.removeItem("jwt");
          setMe(null);
          setPage("login");
        }

        async function refreshMe() {
          const jwt = localStorage.getItem("jwt");
          if (!jwt) {
            setMe(null);
            return;
          }
          const rr = await fetch("/api/auth/me", {
            headers: { Authorization: "Bearer " + jwt },
          });
          const dd = await rr.json();
          if (rr.ok) setMe(dd.user);
          else setMe(null);
        }

        return (
          <React.Fragment>
            {!me && page === "login" && <Login onAuthed={onAuthed} />}
            {!me && page === "register" && <Register onAuthed={onAuthed} />}
            {me && page === "dashboard" && (
              <Dashboard me={me} onLogout={logout} refreshMe={refreshMe} />
            )}
            {!me && page === "dashboard" && (
              <div className="card">
                <p>Please login first.</p>
              </div>
            )}
          </React.Fragment>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
